<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>OLED Editor ‚Äî Herramientas completas</title>
<style>
  :root{--bg:#fff;--fg:#111}
  body{background:var(--bg);color:var(--fg);font-family:Inter,Arial,Helvetica,sans-serif;margin:18px;text-align:center}
  h1{margin:6px 0 12px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;align-items:center;margin-bottom:10px}
  .controls select,.controls button,.controls input[type="number"],.controls input[type="text"]{
    padding:8px;border-radius:6px;border:1px solid #222;background:#fff;color:#111;font-size:14px;min-width:fit-content;
  }
  button.primary{background:#111;color:#fff;border:none}
  .toolbar{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
  .toolbar button{padding:8px 10px;border-radius:6px;border:1px solid #222;background:#fff;cursor:pointer}
  #canvas{border:1px solid #000; image-rendering: pixelated; cursor:crosshair; display:block; margin: 0 auto;}
  #preview{border:2px solid #000; image-rendering: pixelated; display:block; margin:10px auto}
  textarea{width:92%;height:160px;margin-top:12px;font-family:monospace;padding:8px}
  label.small{font-size:13px;margin-left:6px}
  .row{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap}
  input[type=file]{display:none}
  .file-label{padding:8px 12px;border:1px solid #222;border-radius:6px;cursor:pointer}
  .hint{font-size:13px;color:#444;margin-top:6px}
</style>
</head>
<body>
<h1>OLED Editor ‚Äî Herramientas (128√ó64 / 128√ó32)</h1>

<div class="controls">
  <label>Resoluci√≥n:
    <select id="res">
      <option value="128x64">128 x 64</option>
      <option value="128x32">128 x 32</option>
    </select>
  </label>

  <label>Zoom:
    <select id="zoom">
      <option value="4">4x</option>
      <option value="6" selected>6x</option>
      <option value="8">8x</option>
      <option value="10">10x</option>
    </select>
  </label>

  <button id="undo">‚§∫ Deshacer</button>
  <button id="redo">‚§ª Rehacer</button>
  <button id="clear">üßº Borrar</button>
  <button id="invert">üåì Invertir</button>
  <button id="exportPNG" class="primary">‚¨á Exportar PNG</button>
  <button id="gen" class="primary">üíæ Generar C++</button>
</div>

<div class="toolbar" id="tools">
  <button data-tool="brush">‚úèÔ∏è Pincel</button>
  <button data-tool="erase">üßΩ Borrador</button>
  <button data-tool="line">üìè L√≠nea</button>
  <button data-tool="rect">‚ñ≠ Rect√°ngulo</button>
  <button data-tool="circle">‚ö™ C√≠rculo</button>
  <button data-tool="triangle">üî∫ Tri√°ngulo</button>
  <button data-tool="text">üî§ Texto</button>
  <label class="small">Relleno <input type="checkbox" id="fill"></label>
  <label class="small">Tama√±o texto <input type="number" id="textSize" value="8" min="6" max="32" style="width:60px"></label>
  <label class="small">Umbral import <input type="number" id="threshold" value="128" min="0" max="255" style="width:70px"></label>
</div>

<div class="row">
  <canvas id="canvas"></canvas>
</div>

<h3>Vista previa OLED 1:1</h3>
<canvas id="preview" width="128" height="64"></canvas>

<div class="row" style="margin-top:10px">
  <label class="file-label">
    üìÅ Importar imagen
    <input type="file" accept="image/png,image/jpeg" id="fileInput">
  </label>

  <input id="textInput" type="text" placeholder="Texto para herramienta Texto" style="width:230px"/>
  <button id="applyText">Aplicar Texto</button>
</div>

<textarea id="output" placeholder="Aqu√≠ aparece el c√≥digo C++..."></textarea>
<div class="hint">Haz clic-drag para dibujar. Para formas: arrastra desde el punto inicial hasta soltar para crear la figura.</div>

<script>
/* ---------------------------
   Configuraci√≥n y estado
   --------------------------- */
const resSel = document.getElementById('res');
const zoomSel = document.getElementById('zoom');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const preview = document.getElementById('preview');
const pctx = preview.getContext('2d');
const output = document.getElementById('output');
const thresholdInput = document.getElementById('threshold');
const textInput = document.getElementById('textInput');
const textSizeInput = document.getElementById('textSize');
const fillCheckbox = document.getElementById('fill');

let W = 128, H = 64, Z = 6;
let pixels = []; // matriz [y][x] 0/1

// undo/redo
const undoStack = [];
const redoStack = [];
const UNDO_LIMIT = 60;

// herramienta actual
let tool = 'brush';
document.querySelectorAll('#tools button').forEach(b=>{
  b.onclick = ()=>{ tool = b.dataset.tool; highlightTool(); }
});
function highlightTool(){
  document.querySelectorAll('#tools button').forEach(b=>{
    b.style.boxShadow = (b.dataset.tool===tool) ? 'inset 0 0 0 2px #000' : 'none';
  });
}
highlightTool();

/* ---------------------------
   Inicializaci√≥n
   --------------------------- */
function initPixels(){
  pixels = Array.from({length: H}, ()=> new Uint8Array(W));
}
function resizeCanvas(){
  [W,H] = resSel.value.split('x').map(Number);
  Z = Number(zoomSel.value);
  canvas.width = W * Z;
  canvas.height = H * Z;
  canvas.style.width = (W*Z) + 'px';
  canvas.style.height = (H*Z) + 'px';

  preview.width = W;
  preview.height = H;
  initPixels();
  clearStacks();
  pushState(); // inicial state
  renderAll();
}
function clearStacks(){ undoStack.length=0; redoStack.length=0; }

resizeCanvas();

/* ---------------------------
   Estado (undo/redo)
   --------------------------- */
function clonePixels(){
  return pixels.map(row => Uint8Array.from(row));
}
function pushState(){
  undoStack.push(clonePixels());
  if(undoStack.length>UNDO_LIMIT) undoStack.shift();
  redoStack.length=0;
}
function undo(){
  if(undoStack.length<=1) return;
  const last = undoStack.pop();
  redoStack.push(last);
  const prev = undoStack[undoStack.length-1];
  pixels = prev.map(r=>Uint8Array.from(r));
  renderAll();
}
function redo(){
  if(redoStack.length===0) return;
  const next = redoStack.pop();
  undoStack.push(next.map(r=>Uint8Array.from(r)));
  pixels = next.map(r=>Uint8Array.from(r));
  renderAll();
}
document.getElementById('undo').onclick = ()=>undo();
document.getElementById('redo').onclick = ()=>redo();

/* ---------------------------
   Render (zoomed + preview)
   --------------------------- */
function renderAll(){
  // zoomed canvas
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(pixels[y][x]){
        ctx.fillStyle = '#000';
        ctx.fillRect(x*Z, y*Z, Z, Z);
      }
    }
  }
  // preview 1:1
  pctx.fillStyle='#fff';
  pctx.fillRect(0,0,preview.width,preview.height);
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(pixels[y][x]){
        pctx.fillStyle='#000';
        pctx.fillRect(x,y,1,1);
      }
    }
  }
}

/* ---------------------------
   Interacci√≥n: rat√≥n/tacto
   - Para pincel/borrador: dibuja al mover.
   - Para formas (line,rect,circle,triangle,text) usamos mouse down->start, mouse up->end y preview de forma.
   --------------------------- */
let isDown=false, startX=0, startY=0, tempPixels=null;

canvas.addEventListener('mousedown', e=>{
  isDown=true;
  const [x,y] = eventToXY(e);
  startX=x; startY=y;

  if(tool==='brush' || tool==='erase'){
    pushState();
    paintPixel(x,y, tool==='brush' ? 1 : 0);
    renderAll();
  } else {
    // snapshot for preview while dragging
    tempPixels = clonePixels();
  }
});
canvas.addEventListener('mousemove', e=>{
  if(!isDown) return;
  const [x,y] = eventToXY(e);
  if(tool==='brush' || tool==='erase'){
    paintPixel(x,y, tool==='brush' ? 1 : 0);
    renderAll();
  } else {
    // show shape preview: render shape on a copy and draw
    pixels = tempPixels.map(r=>Uint8Array.from(r));
    drawShapePreview(tool, startX, startY, x, y, fillCheckbox.checked);
    renderAll();
  }
});
window.addEventListener('mouseup', e=>{
  if(!isDown) return;
  isDown=false;
  const [x,y] = eventToXY(e);
  if(tool!=='brush' && tool!=='erase'){
    // finaliza forma
    pixels = tempPixels.map(r=>Uint8Array.from(r));
    drawShapePreview(tool, startX, startY, x, y, fillCheckbox.checked);
    pushState();
    tempPixels = null;
    renderAll();
  } else {
    pushState();
  }
});

function eventToXY(e){
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left);
  const cy = (e.clientY - rect.top);
  const x = Math.floor(cx / Z);
  const y = Math.floor(cy / Z);
  return [clamp(x,0,W-1), clamp(y,0,H-1)];
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function paintPixel(x,y,val){
  pixels[y][x] = val?1:0;
}

/* ---------------------------
   Shape drawing helpers
   --------------------------- */
function drawShapePreview(kind, x0,y0, x1,y1, filled){
  if(kind==='line') drawLine(x0,y0,x1,y1,1);
  else if(kind==='rect') drawRect(Math.min(x0,x1), Math.min(y0,y1), Math.abs(x1-x0)+1, Math.abs(y1-y0)+1, 1, filled);
  else if(kind==='circle') drawCircle(x0,y0, Math.round(distance(x0,y0,x1,y1)), 1, filled);
  else if(kind==='triangle') {
    // triangle defined by start, end and third point mirrored for convenience
    const x2 = x0; const y2 = y1;
    drawTriangle([x0,y0],[x1,y1],[x2,y2],1,filled);
  } else if(kind==='text') {
    stampTextAt(textInput.value || '', x0,y0, Number(textSizeInput.value) || 8);
  }
}
// utility distance
function distance(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }

/* Bresenham line */
function drawLine(x0,y0,x1,y1,val){
  x0=Math.floor(x0);y0=Math.floor(y0);x1=Math.floor(x1);y1=Math.floor(y1);
  let dx=Math.abs(x1-x0), sx = x0 < x1 ? 1 : -1;
  let dy=-Math.abs(y1-y0), sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while(true){
    if(inBounds(x0,y0)) pixels[y0][x0]=val;
    if(x0===x1 && y0===y1) break;
    let e2 = 2*err;
    if(e2 >= dy){ err += dy; x0 += sx; }
    if(e2 <= dx){ err += dx; y0 += sy; }
  }
}

/* Rectangle */
function drawRect(x,y,w,h,val,filled=false){
  x=Math.floor(x); y=Math.floor(y); w=Math.floor(w); h=Math.floor(h);
  if(filled){
    for(let yy=y; yy<y+h; yy++){
      if(yy<0||yy>=H) continue;
      for(let xx=x; xx<x+w; xx++){
        if(xx<0||xx>=W) continue;
        pixels[yy][xx]=val;
      }
    }
  } else {
    drawLine(x,y,x+w-1,y,val);
    drawLine(x,y,x,y+h-1,val);
    drawLine(x+w-1,y,x+w-1,y+h-1,val);
    drawLine(x,y+h-1,x+w-1,y+h-1,val);
  }
}

/* Circle (Midpoint) */
function drawCircle(cx,cy,r,val,filled=false){
  cx=Math.floor(cx); cy=Math.floor(cy); r=Math.floor(r);
  let x = r, y = 0, err = 0;
  if(filled){
    while(x >= y){
      // draw horizontal spans between symmetric points
      for(let yy=-y; yy<=y; yy++){
        safeSet(cx - x, cy + yy, val);
        safeSet(cx + x, cy + yy, val);
      }
      for(let yy=-x; yy<=x; yy++){
        safeSet(cx - y, cy + yy, val);
        safeSet(cx + y, cy + yy, val);
      }
      y += 1;
      if (err <= 0) { err += 2*y + 1; }
      if (err > 0) { x -= 1; err -= 2*x + 1; }
    }
  } else {
    while(x >= y){
      safeSet(cx + x, cy + y, val);
      safeSet(cx + y, cy + x, val);
      safeSet(cx - y, cy + x, val);
      safeSet(cx - x, cy + y, val);
      safeSet(cx - x, cy - y, val);
      safeSet(cx - y, cy - x, val);
      safeSet(cx + y, cy - x, val);
      safeSet(cx + x, cy - y, val);
      y += 1;
      if (err <= 0) { err += 2*y + 1; }
      if (err > 0) { x -= 1; err -= 2*x + 1; }
    }
  }
}

/* Triangle (filled with scanline) */
function drawTriangle(a,b,c,val,filled=false){
  // a,b,c are arrays [x,y]
  if(!Array.isArray(a)) return;
  if(!filled){
    drawLine(a[0],a[1],b[0],b[1],val);
    drawLine(b[0],b[1],c[0],c[1],val);
    drawLine(c[0],c[1],a[0],a[1],val);
    return;
  }
  // filled: scanline algorithm
  let pts = [a,b,c].map(p=>({x:p[0],y:p[1]})).sort((p,q)=>p.y-q.y);
  const [p0,p1,p2] = pts;
  function edgeInterp(y, pa, pb){
    if(pa.y===pb.y) return pa.x;
    return Math.round(pa.x + (pb.x - pa.x) * ((y - pa.y) / (pb.y - pa.y)));
  }
  for(let y = Math.max(0,p0.y); y <= Math.min(H-1,p2.y); y++){
    let xa = (y <= p1.y) ? edgeInterp(y,p0,p1) : edgeInterp(y,p0,p2);
    let xb = (y <= p1.y) ? edgeInterp(y,p0,p2) : edgeInterp(y,p1,p2);
    if(xa>xb) [xa,xb]=[xb,xa];
    for(let x=xa; x<=xb; x++) safeSet(x,y,val);
  }
}

function drawTriangle(a,b,c,val,f){
  // overloaded: if called with arrays
  if(Array.isArray(a)){
    drawTriangle(a,b,c,val,f);
    return;
  }
}

/* helper safe set */
function safeSet(x,y,val){ if(inBounds(x,y)) pixels[y][x]=val; }
function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }

/* stamp text by drawing into temp canvas at 1:1 and thresholding */
function stampTextAt(text, tx, ty, size=8){
  if(!text) return;
  // offscreen canvas sized to W,H
  const tmp = document.createElement('canvas');
  tmp.width = W; tmp.height = H;
  const tctx = tmp.getContext('2d');
  tctx.fillStyle = '#fff'; tctx.fillRect(0,0,tmp.width,tmp.height);
  tctx.fillStyle = '#000';
  tctx.font = `${size}px sans-serif`;
  tctx.textBaseline = 'top';
  // draw text at tx,ty but ensure within canvas
  tctx.fillText(text, tx, ty);
  const data = tctx.getImageData(0,0,W,H).data;
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const i = (y*W + x)*4;
      const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
      pixels[y][x] = lum < 128 ? 1 : pixels[y][x];
    }
  }
}

/* ---------------------------
   Import image (mono)
   --------------------------- */
document.getElementById('fileInput').addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  const img = await loadImageFromFile(f);
  // draw into temp canvas sized W x H
  const tmp = document.createElement('canvas'); tmp.width = W; tmp.height = H;
  const tctx = tmp.getContext('2d');
  // fit image preserving aspect ratio, center
  const ar = img.width / img.height;
  let dw=W, dh=H;
  if(dw/dh > ar){ dw = Math.round(dh * ar); } else { dh = Math.round(dw / ar); }
  const dx = Math.floor((W - dw)/2), dy = Math.floor((H - dh)/2);
  tctx.fillStyle='#fff'; tctx.fillRect(0,0,W,H);
  tctx.drawImage(img, dx, dy, dw, dh);
  const data = tctx.getImageData(0,0,W,H).data;
  const thr = Number(thresholdInput.value) || 128;
  pushState();
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const i=(y*W+x)*4;
      const lum = 0.299*data[i]+0.587*data[i+1]+0.114*data[i+2];
      pixels[y][x] = lum < thr ? 1 : 0;
    }
  }
  renderAll();
});
function loadImageFromFile(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); }
    img.onerror = reject;
    img.src = url;
  });
}

/* ---------------------------
   Buttons: clear, invert, export, generate C++
   --------------------------- */
document.getElementById('clear').onclick = ()=>{
  pushState();
  initPixels();
  renderAll();
  output.value='';
};
document.getElementById('invert').onclick = ()=>{
  pushState();
  for(let y=0;y<H;y++) for(let x=0;x<W;x++) pixels[y][x] = pixels[y][x] ? 0 : 1;
  renderAll();
};
document.getElementById('exportPNG').onclick = ()=>{
  // export preview scaled up for visibility: create a temp canvas larger (optional)
  const scale = 4; // downloadable size
  const tmp = document.createElement('canvas');
  tmp.width = W * scale; tmp.height = H * scale;
  const tctx = tmp.getContext('2d');
  // draw white background then scale preview with pixelated
  tctx.fillStyle='#fff'; tctx.fillRect(0,0,tmp.width,tmp.height);
  // draw each pixel as rect
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(pixels[y][x]) tctx.fillRect(x*scale,y*scale,scale,scale);
    }
  }
  const link = document.createElement('a');
  link.download = `oled_${W}x${H}.png`;
  link.href = tmp.toDataURL();
  link.click();
};

/* Generar C++ (byte columns per page) */
document.getElementById('gen').onclick = ()=>{
  const bytes = [];
  for(let page=0; page<Math.ceil(H/8); page++){
    for(let x=0;x<W;x++){
      let b=0;
      for(let bit=0; bit<8; bit++){
        const y = page*8 + bit;
        if(y < H && pixels[y][x]) b |= (1 << bit);
      }
      bytes.push(b);
    }
  }
  const hex = bytes.map(v=>'0x'+v.toString(16).padStart(2,'0')).join(', ');
  output.value =
`// ${W}x${H} monochrome bitmap
const uint8_t image[] = {
  ${hex}
};
// display.drawBitmap(0,0,image,${W},${H}, WHITE);`;
};

/* Apply text button */
document.getElementById('applyText').onclick = ()=>{
  pushState();
  stampTextAt(textInput.value||'', 0, 0, Number(textSizeInput.value) || 8);
  renderAll();
};

/* ---------------------------
   Utility functions
   --------------------------- */
function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }

/* ---------------------------
   Shape drawing wrapper functions using helpers above
   (we already defined drawLine, drawRect, drawCircle, drawTriangle)
   --------------------------- */
// Those functions operate on the global pixels array.

/// Prevent context menu on right click, use right click as erase
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('mousedown', e=>{
  if(e.button===2){ // right click: erase tool temporarily
    tool = 'erase';
    canvas.isRightErase = true;
    highlightTool();
  }
});
window.addEventListener('mouseup', ()=>{
  if(canvas.isRightErase){
    canvas.isRightErase = false;
    tool = 'brush';
    highlightTool();
  }
});

/* resize when controls change */
resSel.onchange = resizeCanvas;
zoomSel.onchange = ()=>{ Z = Number(zoomSel.value); resizeCanvas(); };

/* initialize render */
renderAll();

/* small helpers not previously defined due to hoisting */
function drawTriangle(a,b,c,val,filled){ // ensure correct dispatch
  // If a is array of coords
  if(Array.isArray(a) && Array.isArray(b) && Array.isArray(c)){
    // reuse earlier triangle function (we wrote a version earlier that expected arrays)
    // simple approach: use polygon fill via canvas then threshold back
    const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
    const t = tmp.getContext('2d');
    t.fillStyle='#fff'; t.fillRect(0,0,W,H);
    t.beginPath();
    t.moveTo(a[0],a[1]); t.lineTo(b[0],b[1]); t.lineTo(c[0],c[1]); t.closePath();
    t.fillStyle = filled ? '#000' : '#000';
    if(filled) t.fill(); else t.stroke();
    const data = t.getImageData(0,0,W,H).data;
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const i=(y*W+x)*4; const lum = 0.299*data[i]+0.587*data[i+1]+0.114*data[i+2];
      if(lum<128) pixels[y][x]=val;
    }
    return;
  }
}

/* drawRect wrapper already defined earlier but ensure no conflict */
function drawRect(x,y,w,h,val,filled){ // override safe one
  if(filled){
    for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) safeSet(xx,yy,val);
  } else {
    drawLine(x,y,x+w-1,y,val);
    drawLine(x,y,x,y+h-1,val);
    drawLine(x+w-1,y,x+w-1,y+h-1,val);
    drawLine(x,y+h-1,x+w-1,y+h-1,val);
  }
}

/* drawCircle wrapper */
function drawCircle(cx,cy,r,val,filled){
  // simple rasterized circle using midpoint algorithm already implemented above earlier; reuse that version
  // implement quick version (outline only or filled)
  let x = r, y = 0, err = 0;
  if(filled){
    while(x >= y){
      for(let yy=-y; yy<=y; yy++){ safeSet(cx-x, cy+yy, val); safeSet(cx+x,cy+yy,val); }
      for(let yy=-x; yy<=x; yy++){ safeSet(cx-y, cy+yy, val); safeSet(cx+y,cy+yy,val); }
      y++; if(err <= 0) err += 2*y+1; if(err > 0) { x--; err -= 2*x + 1; }
    }
  } else {
    while(x >= y){
      safeSet(cx + x, cy + y, val);
      safeSet(cx + y, cy + x, val);
      safeSet(cx - y, cy + x, val);
      safeSet(cx - x, cy + y, val);
      safeSet(cx - x, cy - y, val);
      safeSet(cx - y, cy - x, val);
      safeSet(cx + y, cy - x, val);
      safeSet(cx + x, cy - y, val);
      y++; if(err <= 0) err += 2*y+1; if(err > 0) { x--; err -= 2*x + 1; }
    }
  }
}
</script>
</body>
                                                  </html>
